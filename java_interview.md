## ☕️ 자바 면접 질문 정리

<details>
<summary>자바의 Wrapper 클래스는 무엇이며, 왜 사용하나요?</summary>

<br/>

Wrapper 클래스는 기본 데이터타입을 객체로 다루기 위해 자바에서 제공하는 클래스입니다. 기본 타입은 객체가 아니기 때문에 객체가 필요한 경우 Wrapper 타입을 사용합니다. 예를 들어,컬렉션과 같은 객체만 취급하는 구조에서 Wrapper 클래스를 사용해 기본 타입을 객체로 래핑해서 사용할 수 있습니다.

<br/>

</details>

<details>
<summary>자바에서 오토박싱과 오토언박싱에 대해 설명해주세요</summary>

<br/>

오토박싱(Autoboxing) 은 자바에서 기본 데이터 타입을 자동으로 해당하는 Wrapper 클래스로 변환하는 과정입니다. 오토언박싱(Unboxing) 은 반대로 Wrapper 객체를 기본 데이터타입으로 자동 변환하는 과정입니다. JDK1.5(자바5) 부터 자동 변환이 지원되어 개발자가 명시적으로 변환할 필요 없이 편리하게 사용할 수 있습니다. 예를 들어, 기본타입과 래퍼타입간 연산이 필요할 때 컴파일러가 자동으로 래퍼타입을 기본타입으로 오토언박싱해 연산을 수행합니다.

<br/>

### 추가 설명

int 와 Integer 를 예로 들자면

Boxing 할때는 Integer.valueOf() 메서드를 사용합니다.

```java
Integer num = Integer.valueOf(10);
```

Unboxing 할때는 Integer.intValue() 메서드를 사용합니다.

```java
int num = Integer.intValue(new Integer(10));
```

이 과정을 컴파일러가 아래처럼 대신 해주는것이 오토박싱과 오토 언박싱 입니다.

```java
int primitiveInt = 10;
Integer wrapperInt = primitiveInt; // 자동으로 Integer로 변환 (오토박싱)

Integer wrapperInt = Integer.valueOf(20);
int primitiveInt = wrapperInt; // 자동으로 int로 변환 (오토언박싱)
```

</details>

<details>
<summary>기본타입과 래퍼타입의 차이점과 어떤 경우에 기본 타입을 사용해야 할 지 설명해 주세요</summary>

<br/>

기본 타입은 메모리의 스택(stack) 영역에 직접 저장되며, 객체가 아닌 값 자체가 저장됩니다. 반면 래퍼 타입은 메모리의 힙(heap) 영역에 객체로 저장되며, 객체가 참조 변수에 의해 참조됩니다. 기본 타입의 초기화 값은 0 또는 false 와 같은 값으로 null 을 가질 수 없지만 래퍼 타입은 객체이기 때문에 명시적으로 초기화 하지 않는 경우 null 을 가집니다. 또한 래퍼 타입은 불변(immutable) 이므로 객체를 생성한 후에는 그 값을 변경할 수 없습니다. 수정이나 값을 변경할 때는 객체의 값을 변경하는게 아닌, 새로운 값의 객체를 생성해서 반환받습니다. 반면, 기본 타입은 값이 변경될 수 있습니다. 메모리 효율성의 경우 래퍼 타입은 객체를 생성하기 때문에 추가적인 메모리 오버헤드가 발생합니다. 따라서 기본 타입은 성능이 중요한 경우나 단순히 연산을 수행할 때 주로 사용됩니다. 래퍼 타입은 객체를 요구하는 컬렉션 프레임워크나 제네릭에서 주로 사용됩니다.

<br/>

### 추가 설명

자바의 제네릭은 컴파일 시 타입 안전성을 제공하고, 컴파일러는 제네릭을 사용하여 타입 변환을 제거하기 위해 타입 소거(Type Erasure) 를 사용합니다. 이 과정에서 제네릭 클래스의 타입 매개변수는 객체 타입으로 변환되는데, 기본 타입은 객체가 아니기 때문에 제네릭에 사용할 수 없습니다.

</details>

<details>
<summary>추상 클래스와 인터페이스의 차이를 설명해주세요.</summary>

<br/>

추상 클래스나 인터페이스는 추상 메소드를 이용한 구현 원칙을 강제한다는 점은 동일하지만, 추상 클래스는 클래스로서 `클래스와 의미있는 연관관계를 구축`할 때 사용하고, 인터페이스는 `클래스와 별도로 구현 객체가 같은 동작`을 한다는 것을 보장하기 위해 사용합니다. </br>
예시로 동물이라는 추상 클래스를 상속한 앵무새, 고래, 사자라는 클래스가 존재합니다. 동작을 하는 메소드 추가를 위해 수영 동작을 하는 `swimming()` 메소드를 자식 클래스에 추가하려고 합니다. 추후 확장을 위해 추상화 원칙을 따르기 위해 추상 클래스에 추상 메서드인 `swimming()` 메소드를 추가하면 수영을 못하는 앵무새와 사자 클래스도 반드시 해당 메소드를 구현해야한다는 강제성이 생깁니다. 이때 상속에 얽매이지 않는 인터페이스에 추상 메서드를 선언하고 이를 구현하게 하면 `자유로운 타입 묶음을 통해 추상화를 이루게`할 수 있습니다.

<img src="https://github.com/user-attachments/assets/beca0fea-3815-4c33-bcdb-5587538cc7e3" />

<br/>

</details>