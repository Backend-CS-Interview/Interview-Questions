<details>
<summary>this와 super의 차이를 알려주세요.</summary>
<br/>
this는 자기 자신의 메모리를 가르키거나, 생성자에서 다른 생성자를 호출할 경우에, 혹은 인스턴스 자신의 주소를 반환할 때 사용합니다.
이와 반대로 super는 상속관계에 있을 때 자식클래스에서 사용을 합니다. 자식 클래스에서 같은 이름의 데이터 멤버가 있는 경우 부모 클래스의 데이터 멤버에 액세스하거나, 부모 클래스의 기본 생성자, 혹은 매개 변수가 있는 생성자를 호출합니다. 또한 자식 클래스에서 재정의된 메서드가 있을 때, 부모 클래스의 메서드를 호출하고 싶은 경우에도 super를 사용합니다.

```java
class Animal {
    String name;

    // 부모 클래스의 생성자
    Animal(String name) {
        // this를 사용하여 인스턴스 변수와 매개변수 구분
        this.name = name;
    }

    void sound() {
        System.out.println(name + " makes a sound.");
    }
}

class Dog extends Animal {
    int age;

    // 자식 클래스의 생성자
    Dog(String name, int age) {
        // super를 사용하여 부모 클래스의 생성자 호출
        super(name);
        // this를 사용하여 인스턴스 변수와 매개변수 구분
        this.age = age;
    }

    // 부모 클래스의 메서드를 재정의
    @Override
    void sound() {
        // super를 사용하여 부모 클래스의 메서드 호출
        super.sound();
        System.out.println(name + " barks.");
    }

    void displayInfo() {
        // this를 사용하여 현재 객체의 메서드를 호출
        System.out.println("Dog's Name: " + this.name);
        System.out.println("Dog's Age: " + this.age);
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog("Buddy", 5);

        // this 키워드를 사용하는 메서드
        dog.displayInfo();

        // super 키워드를 사용하는 메서드
        dog.sound();
    }
}
```
출력은 아래와 같다.

```md
Dog's Name: Buddy
Dog's Age: 5
Buddy makes a sound.
Buddy barks.
```
<br/>
</details>

<details>
<summary>List와 Stream의 차이에 대해 알려주세요.</summary>
<br/>
먼저 목적에 있어서 차이가 있습니다. List는 정보를 저장하는 것이 목적이라면, Stream은 데이터를 처리하는 데에 목적이 있습니다. 이러한 목적의 차이로 인해 데이터 변경의 가능성은 List에서는 있지만, Stream은 없고 저장 공간을 독립적으로 갖지 않습니다. Stream은 Lazy 실행을 구현하였기에 계산이 필요없는 데이터에는 관심이 없어 데이터 처리에서 list보다 상대적으로 빠르다는 장점이 있습니다. Stream은 또한 parallelStream을 사용하여 병렬화를 쉽게 할 수 있습니다.
<br/>
</details>

<details>
<summary>Java에서 직렬화가 무엇인지 설명해주세요.</summary>
<br/>
직렬화는 java에서 사용되는 object나 data들을 다른 컴퓨터의 java 시스템에서도 사용할 수 있도록 바이트 스트림 형태로 연속적인 데이터로 바꾸는 포맷 변환 기술입니다. JVM의 heap이나 stack 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여 외부 저장소에 저장하는 것입니다.

<br/>
<details style="margin-left: 20px;">
<summary>변환된 데이터를 다른 컴퓨터에서 어떻게 읽나요?</summary>
<br/>
직렬화된 데이터(바이트 스트림)를 네트워크나 파일 등으로부터 입력받은 후 이를 역직렬화하여 메모리에 원래의 객체를 다시 생성합니다. 이 때 기존 컴퓨터와 다른 컴퓨터는 동일한 클래스 구조를 공유하고 있어야 하고 serialVersionUID와 같은 클래스 버전이 일치해야합니다.

<br/>
</details>

<details style="margin-left: 20px;">
<summary>직렬화와 Json의 차이를 알려주세요.</summary>
<br/>
직렬화는 java에서만 사용하지만 json은 웹 뿐만 아니라 게임 등에서도 사용가능하고,
python, javascript 등 범용성 있게 사용이 가능합니다.

<br/>
</details>

<details style="margin-left: 20px;">
<summary>직렬화의 장점과 단점을 알려주세요.</summary>
<br/>
자바 직렬화의 장점은 먼저 자바에 최적화되어 있고, 자바의 reference 타입, 예를 들어 class나 interface에 대해 제약 없이 외부에 내보낼 수 있습니다.
단점으로는 직렬화는 데이터 뿐만 아니라 타입 정보, 클래스 메타 데이터 등을 가지고 있어 json에 비해 2배 이상 큽니다. 또한 역직렬화는 생성자 없이 인스턴스화가 가능하기에 보안 문제가 존재합니다.

<br/>
</details>
<br/>
</details>

<details>
<summary>static, final, 그리고 static final의 차이를 설명해주세요.</summary>
<br/>
static 키워드를 가진 멤버는 값이 클래스의 모든 인스턴스에 대해 동일하여 전역이라고 이해할 수 있고, 상수가 아니기에 변경될 수 있습니다. 그리고 메소드 영역에 저장되어 Garbage collector가 작동하지 않아 시스템 종료까지 메모리에 남게 됩니다.
final 키워드가 붙은 변수는 상수입니다. 하지만 값을 받아 오기 전까지는 final 변수에 어떤 값이든 넣을 수 있어 완전한 상수라고는 할 수 없습니다.
static final은 이름에서 보이듯 static과 final을 합친 것으로, 클래스의 모든 인스턴스에 대해 동일함과 동시에 변수에 값이 할당되면 절대 변경할 수 없는 상수를 만드는 방법입니다. 따라서 static에서 변할 수 없고, final이지만 처음부터 값을 할당해야만 하는 키워드입니다.

<br/>
</details>

<details>
<summary>java servlet이 무엇인지 설명해주세요.</summary>
<br/>

java servlet은 클라이언트가 요청을 하면 서버는 이 요청을 확인 후 응답하고 이를 전달해야하는데, 이 때 응답을 전달해주는 것이 servlet입니다. 그래서 servlet은 java로 구현된 CGI라고도 합니다.

<details style="margin-left: 20px;">
<summary>CGI가 무엇인가요?</summary>
<br/>

Common Gateway Interface의 약자로, 특별한 것이 아니라 서버와 애플리케이션 간에 데이터를 주고 받는 방식, 혹은 컨벤션을 CGI라고 합니다.

<br/>
</details>

<details style="margin-left: 20px;">
<summary>servlet의 동작 방식에 대해 설명해주세요.</summary>
<br/>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F993A7F335A04179D20">

먼저 클라이언트가 http 요청을 servlet container로 전달합니다.

servlet container는 HttpServletRequest, Response 객체를 생성합니다. 

web.xml을 기반으로 어느 servlet에 대한 요청인지 분석 후, 해당 servlet에서 service 메소드 호출, 클라이언트의 http 요청(get, post)에 따라 doGet(), doPost()를 호출합니다.

이 메소드는 동적 페이지를 생성하고 HttpServletResponse 객체에 응답을 보냅니다.

응답이 끝나면 Request, Response 객체를 모두 제거합니다.

<br/>
</details>

<br/>
</details>

<details>
<summary>Java에서 generic에 대해 설명해주세요.</summary>
<br/>
generic은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정한 타입을 사용하게 하는 방법입니다. 이를 통해 코드의 재사용성을 높이고, 컴파일 시점에서 타입을 체크해주는 기능이기에 객체의 타입 안정성을 높여줍니다.


```java
ArrayList<String> list = new ArrayList<>();
```
위 코드에서 <> 이 괄호가 generic입니다.

### 추가설명
- 제네릭에서 할당받을 수 있는 타입은 Reference타입 뿐입니다. int, double과 같은 primitive type은 제네릭 타입 파라미터로 넘길 수 없습니다.
- static 멤버에 제네릭 타입이 올 수 없습니다.static은 클래스가 동일하게 공유하는 변수로 제네릭 객체가 생성되기 전에 이미 자료 타입이 정해져 있어야 하기 때문입니다.
- 타입 파라미터 기호 네이밍 T - type, E - element(ex.list), K - key(ex. Map<k,v>), V - 리턴 값, 또는 매핑된 값, N - number, <S,U,V> - 2번째, 3번째, 4번째에 선언된 타입
<br/>
</details>

<details>
<summary>인스턴스 변수와 클래스 변수의 차이점을 설명하세요</summary>
<br/>
클래스 변수는 static을 사용하여 클래스 레벨에서 어디서나 선언할 수 있습니다. 이러한 변수는 다양한 객체에 적용될 때 하나의 값만 가질 수 있습니다. 이 변수는 클래스의 특정 객체에 연결되지 않으므로 모든 클래스 멤버가 공유할 수 있습니다.

인스턴스 변수는 클래스 변수에서 static이 빠진 것입니다. 일반적으로 클래스의 모든 인스턴스에서 공유됩니다. 이러한 변수는 여러 객체 간에 고유한 값을 가질 수 있습니다. 인스턴스 변수의 내용은 클래스의 특정 객체 인스턴스와 관련되어 있기 때문에 한 객체 인스턴스와 다른 객체 인스턴스에 완전히 독립적입니다.

```java
class GFG {
    // class variable
    private static final double PI = 3.14159;
    private double radius;
    public GFG(double radius) { this.radius = radius; }
    public double getArea() { return PI * radius * radius; }
    public static void main(String[] args)
    {
        GFG obj = new GFG(5.0);
        System.out.println("Area of circle: "
                           + obj.getArea());
    }
}

class GFG {
    // instance variable
    private String name;
    public void setName(String name) { this.name = name; }
    public String getName() { return name; }
    public static void main(String[] args)
    {
        GFG obj = new GFG();
        obj.setName("John");
        System.out.println("Name " + obj.getName());
    }
}
```

<br/>
</details>

<details>
<summary>Java에서 생성자를 설명해주세요.</summary>

<br/>
생성자는 객체가 생성될 때 자동으로 호출되는 특수한 목적의 메소드입니다. 객체의 초기화를 위해 사용됩니다. 생성자의 이름은 클래스 이름과 동일해야 하고 객체가 생성될 때 한번 호출됩니다. 또한 매개변수 조건에 따라 오버로딩을 통해 여러개를 작성할 수 있습니다. 생성자 코드가 없으면 컴파일러가 자동으로 기본생성자를 생성합니다.
<br/>
</details>

