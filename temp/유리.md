<details>
<summary>부모 클래스의 메소드를 오버라이딩 할 때 더 좁은 범위로 변경하면 컴파일 에러가 발생하는 이유를 설명해주세요.</summary>
<br/>

```java
public class Animal{
    public void bark(){
        System.out.println("동물이 짖는다.");
    }
}

public class Dog extends Animal{
    @Override
    protected void bark(){
        System.out.println("강아지가 짖는다.");
    }
}

// Animal, Dog과 다른 패키지
class DogTest{
    @Test
    void dogBark(){
        Dog dog1 = returnDog();
        Animal dog2 = returnDog();

        dog1.bark(); // 호출 불가능
        dog2.bark(); // 호출 가능
    }

    private Dog returnDog(){
        return new Dog();
    }
}
```
만약 Dog 클래스의 bark 메소드를 Animal 클래스의 bark 메소드의 접근제어자인 public보다 좁은 범위인 protected 또는 private으로 오버라이딩한다면, 클라이언트는 Dog 클래스를 반환받을때는 bark 호출이 불가능해지는 반면에 부모 클래스인 Animal로 반환받으면 호출이 가능해지는 기이한 현상이 발생하게 됩니다. 위와 같은 현상은 객체지향 프로그래밍(OOP)의 기본 원칙인 `리스코프 치환 원칙에 위배`됩니다. <br/>
리스코프 치환 원칙은 `하위 타입은 상위 타입을 대체할 수 있어야 한다`는 것입니다. 대체할 수 있다는 말은, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 의미입니다. 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미이다. <br/>
이 원칙에 따르면, 프로그램에서 상위 타입의 객체를 사용하는 부분에 하위 타입의 객체를 대입하더라도 프로그램의 동작이 변경되지 않아야 합니다. 위의 예제를 바탕으로 클라이언트는 자식 클래스를 반환받으면 메소드 호출이 불가능해지게 됩니다. 그래서 자바는 언어 차원에서 메소드 오버라이딩을 할 때 더 좁은 범위의 접근제어자로 변경할 수 없도록 제약을 두었습니다. 이를 통해 자식 클래스는 부모 클래스와 동일한 퍼블릭 인터페이스를 제공하여 리스코프 치환 원칙을 준수할 수 있게 됩니다.
<br/>
</details>

<details>
<summary>자바에서 String을 불변으로 설정한 이유를 설명해주세요.</summary>
<br/>

```java
public final class String implements java.io.Serializable, Comparable {
	private final byte[] value;
}
```
String 객체를 불변으로 설계한 이유는 성능 이점, 캐싱, 보안, 동기화에서 이점을 얻기 위해서입니다. 

- 성능 이점 <br/>
    String을 String Constant Pool에서 관리를 하여 같은 값에 대해서는 String 객체를 다시 만들지 않고 이미 존재하는 객체를 참조할 수 있기 때문에 Heap 영역의 메모리를 절약할 수 있습니다. 

- 캐싱  <br/>
    ```java
    public int hashCode() {
        // hash의 초기값 = 0, hashIsZero의 초기값 = false
        int h = hash;  
        if (h == 0 && !hashIsZero) {
            h = isLatin1() ? StringLatin1.hashCode(value)
                           : StringUTF16.hashCode(value);
            if (h == 0) {
                hashIsZero = true;
            } else {
                hash = h;
            }
        }
        return h;
    }
    ```
    String의 hashCode() 메서드를 보면 최초 1번만 실제 계산을 수행하고, 이후에는 계산해서 나온 hash code를 재사용하도록 오버라이딩 되어있습니다. 이렇게 캐싱이 가능한 것은 String이 불변 객체라서 변경되지 않는 문자열을 보장하기 때문입니다. 

- 보안  <br/>
    예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데, 만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있습니다. 

- 동기화  <br/>
    String은 불변이기 때문에 멀티 스레드 환경에서 Thread-safe하다는 장점이 있습니다. 스레드가 값을 변경하면 동일한 String을 수정하는 대신 String Constant Pool에 새로운 문자열이 생성되기 때문입니다.
<br/>
</details>