<details>
<summary>부모 클래스의 메소드를 오버라이딩 할 때 더 좁은 범위로 변경하면 컴파일 에러가 발생하는 이유를 설명해주세요.</summary>
<br/>

```java
public class Animal{
    public void bark(){
        System.out.println("동물이 짖는다.");
    }
}

public class Dog extends Animal{
    @Override
    protected void bark(){
        System.out.println("강아지가 짖는다.");
    }
}

// Animal, Dog과 다른 패키지
class DogTest{
    @Test
    void dogBark(){
        Dog dog1 = returnDog();
        Animal dog2 = returnDog();

        dog1.bark(); // 호출 불가능
        dog2.bark(); // 호출 가능
    }

    private Dog returnDog(){
        return new Dog();
    }
}
```
만약 Dog 클래스의 bark 메소드를 Animal 클래스의 bark 메소드의 접근제어자인 public보다 좁은 범위인 protected 또는 private으로 오버라이딩한다면, 클라이언트는 Dog 클래스를 반환받을때는 bark 호출이 불가능해지는 반면에 부모 클래스인 Animal로 반환받으면 호출이 가능해지는 기이한 현상이 발생하게 됩니다. 위와 같은 현상은 객체지향 프로그래밍(OOP)의 기본 원칙인 `리스코프 치환 원칙에 위배`됩니다. <br/>
리스코프 치환 원칙은 `하위 타입은 상위 타입을 대체할 수 있어야 한다`는 것입니다. 대체할 수 있다는 말은, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 의미입니다. 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미이다. <br/>
이 원칙에 따르면, 프로그램에서 상위 타입의 객체를 사용하는 부분에 하위 타입의 객체를 대입하더라도 프로그램의 동작이 변경되지 않아야 합니다. 위의 예제를 바탕으로 클라이언트는 자식 클래스를 반환받으면 메소드 호출이 불가능해지게 됩니다. 그래서 자바는 언어 차원에서 메소드 오버라이딩을 할 때 더 좁은 범위의 접근제어자로 변경할 수 없도록 제약을 두었습니다. 이를 통해 자식 클래스는 부모 클래스와 동일한 퍼블릭 인터페이스를 제공하여 리스코프 치환 원칙을 준수할 수 있게 됩니다.

<br/>
</details>