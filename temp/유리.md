<!-- 2024.09.24 (1) -->
<details>
<summary>자바는 Call by Value인가요? Call by Reference인가요? 이유와 함께 설명해주세요.</summary>
<br/>

자바에는 call by reference 라는 것은 존재하지 않습니다. 왜냐면 C언어와 달리 자바는 포인터를 철저하게 숨겨 개발자가 직접 메모리 주소에 접근하지 못하게 조치했기 때문입니다. 자바에서의 파라미터는 `call by value로서만 동작`되며, 원시값이 복사되느냐 주소값이 복사되느냐의 차이가 있을 뿐입니다. 주소값의 복사는 클래스, 인터페이스, 배열 등과 같이 primitive(원시) 타입이 아닌 모든 타입에 대해서 적용됩니다. <br/>
매개변수에 복사된 값에 따라, 원시값이면 바로 연산을 하고 주소값이면 해당 메모리 주소를 참조해 값을 가져와 연산을 수행합니다. 원시값이 복사되느냐 주소값이 복사되느냐를 구분하기 위해 call by value / call by address로 명명 지어 구분하기도 합니다. 

```java
public class main
{
    public static void main(String[] args)
    {
        Sample sample = new Sample();

        int var = 1; // primitive 타입 변수 int
        int[] arr = { 1 }; // reference 타입 변수 int[] 배열

        add_value(var);
        System.out.println(var); // 1 : 값 변화가 없음

        add_reference(arr);
        System.out.println(arr[0]); // 101 : 값이 변화함
    }

    static void add_value(int var_arg) {
        var_arg += 100;
    }

    static void add_reference(int[] arr_arg) {
        arr_arg[0] += 100;
    }
}
```
- add_value 스택 프레임 안에 있는 변수 `var_arg`가 바뀐 것이지, main 스택 프레임 안에 있는 변수 `var`가 바뀐 것이 아닙니다. 매개변수 `var_arg`는 그저 변수 `var`로부터 원시값을 복사하여 받은 것 뿐입니다.

- `add_reference()` 메서드가 호출되면서, add_reference 스택 프레임이 생성되고 그 안에 지역변수(매개변수) `arr_arg`가 생성됩니다. 이때도 변수의 값이 복사되어 파라미터에 넘겨지는데, 자세히 살펴보면 스택 프레임에 있는 `arr` 변수가 들고 있는 값은 `주소 값` 입니다. 따라서 메서드의 입력값으로 주소값이 복사되어 넘겨집니다. 결과적으로 두 변수 `arr`와 `arr_arg`는 같은 주소값을 들고 있게 되고, heap 영역에 있는 하나의 데이터를 동시에 참조하고 있는 것입니다.

<br/>
</details>
<!-- 2024.09.24 (1) -->


<details>
<summary>부모 클래스의 메소드를 오버라이딩 할 때 더 좁은 범위로 변경하면 컴파일 에러가 발생하는 이유를 설명해주세요.</summary>
<br/>

```java
public class Animal{
    public void bark(){
        System.out.println("동물이 짖는다.");
    }
}

public class Dog extends Animal{
    @Override
    protected void bark(){
        System.out.println("강아지가 짖는다.");
    }
}

// Animal, Dog과 다른 패키지
class DogTest{
    @Test
    void dogBark(){
        Dog dog1 = returnDog();
        Animal dog2 = returnDog();

        dog1.bark(); // 호출 불가능
        dog2.bark(); // 호출 가능
    }

    private Dog returnDog(){
        return new Dog();
    }
}
```
만약 Dog 클래스의 bark 메소드를 Animal 클래스의 bark 메소드의 접근제어자인 public보다 좁은 범위인 protected 또는 private으로 오버라이딩한다면, 클라이언트는 Dog 클래스를 반환받을때는 bark 호출이 불가능해지는 반면에 부모 클래스인 Animal로 반환받으면 호출이 가능해지는 기이한 현상이 발생하게 됩니다. 위와 같은 현상은 객체지향 프로그래밍(OOP)의 기본 원칙인 `리스코프 치환 원칙에 위배`됩니다. <br/>
리스코프 치환 원칙은 `하위 타입은 상위 타입을 대체할 수 있어야 한다`는 것입니다. 대체할 수 있다는 말은, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 의미입니다. 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미이다. <br/>
이 원칙에 따르면, 프로그램에서 상위 타입의 객체를 사용하는 부분에 하위 타입의 객체를 대입하더라도 프로그램의 동작이 변경되지 않아야 합니다. 위의 예제를 바탕으로 클라이언트는 자식 클래스를 반환받으면 메소드 호출이 불가능해지게 됩니다. 그래서 자바는 언어 차원에서 메소드 오버라이딩을 할 때 더 좁은 범위의 접근제어자로 변경할 수 없도록 제약을 두었습니다. 이를 통해 자식 클래스는 부모 클래스와 동일한 퍼블릭 인터페이스를 제공하여 리스코프 치환 원칙을 준수할 수 있게 됩니다.
<br/>
</details>

<details>
<summary>자바에서 String을 불변으로 설정한 이유를 설명해주세요.</summary>
<br/>

```java
public final class String implements java.io.Serializable, Comparable {
	private final byte[] value;
}
```
String 객체를 불변으로 설계한 이유는 성능 이점, 캐싱, 보안, 동기화에서 이점을 얻기 위해서입니다. 

- 성능 이점 <br/>
    String을 String Constant Pool에서 관리를 하여 같은 값에 대해서는 String 객체를 다시 만들지 않고 이미 존재하는 객체를 참조할 수 있기 때문에 Heap 영역의 메모리를 절약할 수 있습니다. 

- 캐싱  <br/>
    ```java
    public int hashCode() {
        // hash의 초기값 = 0, hashIsZero의 초기값 = false
        int h = hash;  
        if (h == 0 && !hashIsZero) {
            h = isLatin1() ? StringLatin1.hashCode(value)
                           : StringUTF16.hashCode(value);
            if (h == 0) {
                hashIsZero = true;
            } else {
                hash = h;
            }
        }
        return h;
    }
    ```
    String의 hashCode() 메서드를 보면 최초 1번만 실제 계산을 수행하고, 이후에는 계산해서 나온 hash code를 재사용하도록 오버라이딩 되어있습니다. 이렇게 캐싱이 가능한 것은 String이 불변 객체라서 변경되지 않는 문자열을 보장하기 때문입니다. 

- 보안  <br/>
    예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데, 만일 번지수의 문자열 값이 변경이 가능하다면 해커가 참조값을 변경하여 애플리케이션에 보안 문제를 일으킬 수 있습니다. 

- 동기화  <br/>
    String은 불변이기 때문에 멀티 스레드 환경에서 Thread-safe하다는 장점이 있습니다. 스레드가 값을 변경하면 동일한 String을 수정하는 대신 String Constant Pool에 새로운 문자열이 생성되기 때문입니다.
<br/>
</details>
